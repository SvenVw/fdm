/**
 * @file This file contains functions for managing principals in the FDM.
 *
 * A principal can be either a user or an organization. This module provides functions for
 * retrieving, identifying, and searching for principals.
 */
import { eq, ilike, or } from "drizzle-orm"
import * as authNSchema from "./db/schema-authn"
import { handleError } from "./error"
import type { FdmType } from "./fdm"
import type { Principal } from "./principal.d"

/**
 * Retrieves the details of a principal (user or organization) by their ID.
 *
 * @param fdm The FDM instance for database access.
 * @param principal_id The unique identifier of the principal.
 * @returns A promise that resolves to a `Principal` object, or `undefined` if not found.
 */
export async function getPrincipal(
    fdm: FdmType,
    principal_id: string,
): Promise<Principal | undefined> {
    try {
        return await fdm.transaction(async (tx: FdmType) => {
            // If principal is an user get the details of the user
            const user = await tx
                .select({
                    username: authNSchema.user.username,
                    displayUserName: authNSchema.user.displayUsername,
                    image: authNSchema.user.image,
                    isVerified: authNSchema.user.emailVerified,
                    firstname: authNSchema.user.firstname,
                    surname: authNSchema.user.surname,
                    email: authNSchema.user.email,
                    name: authNSchema.user.name,
                })
                .from(authNSchema.user)
                .where(eq(authNSchema.user.id, principal_id))
                .limit(1)

            if (user.length > 0) {
                // Determine avatar initials
                let initials = user[0].email
                if (user[0].firstname && user[0].surname) {
                    // Select only the first capital letter of firstname and surname
                    initials = user[0].firstname.charAt(0).toUpperCase()

                    // Find the first capital letter in the surname
                    const surnameParts = user[0].surname.split(/\s+/) // Split by one or more spaces
                    let firstCapitalLetterInSurname = ""

                    for (const part of surnameParts) {
                        if (part.length > 0) {
                            const firstChar = part.charAt(0)
                            if (
                                firstChar === firstChar.toUpperCase() &&
                                firstChar.match(/[a-zA-Z]/)
                            ) {
                                firstCapitalLetterInSurname =
                                    firstChar.toUpperCase()
                                break // Stop at the first capital letter found
                            }
                        }
                    }

                    initials += firstCapitalLetterInSurname
                } else if (user[0].firstname) {
                    initials = user[0].firstname[0]
                } else if (user[0].name) {
                    initials = user[0].name[0]
                }

                return {
                    username: user[0].username,
                    initials: initials.toUpperCase(),
                    displayUserName: user[0].displayUserName,
                    image: user[0].image,
                    type: "user",
                    isVerified: user[0].isVerified,
                }
            }

            // If principal is an organization get the details of the organization
            const organization = await tx
                .select({
                    name: authNSchema.organization.name,
                    slug: authNSchema.organization.slug,
                    logo: authNSchema.organization.logo,
                    metadata: authNSchema.organization.metadata,
                })
                .from(authNSchema.organization)
                .where(eq(authNSchema.organization.id, principal_id))
                .limit(1)

            if (organization.length === 0) {
                return undefined
            }
            const metadata = JSON.parse(organization[0].metadata)

            return {
                username: organization[0].slug,
                initials: organization[0].name.charAt(0).toUpperCase(),
                displayUserName: organization[0].name,
                image: organization[0].logo,
                type: "organization",
                isVerified: metadata ? metadata.isVerified : false,
            }
        })
    } catch (err) {
        throw handleError(err, "Exception for getPrincipal", {
            principal_id: principal_id,
        })
    }
}

/**
 * Identifies a principal by a username, email, or organization slug.
 *
 * @param fdm The FDM instance for database access.
 * @param identifier The identifier to search for.
 * @returns A promise that resolves to a `Principal` object with an added `id` property, or `undefined` if not found.
 */
export async function identifyPrincipal(
    fdm: FdmType,
    identifier: string,
): Promise<
    | ({
          id: string
      } & Principal)
    | undefined
> {
    try {
        return await fdm.transaction(async (tx: FdmType) => {
            // Check if principal is an user
            let principal_id = await tx
                .select({ id: authNSchema.user.id })
                .from(authNSchema.user)
                .where(
                    or(
                        eq(authNSchema.user.username, identifier),
                        eq(authNSchema.user.email, identifier),
                    ),
                )
                .limit(1)

            if (principal_id.length === 0) {
                // Check if principal is an organization
                principal_id = await tx
                    .select({ id: authNSchema.organization.id })
                    .from(authNSchema.organization)
                    .where(eq(authNSchema.organization.slug, identifier))
                    .limit(1)
            }

            if (principal_id.length === 0) {
                return undefined
            }

            // Get the type of the principal
            const principalDetails = await getPrincipal(tx, principal_id[0].id)
            // console.log(principalDetails)

            return {
                id: principal_id[0].id,
                ...principalDetails,
            }
        })
    } catch (err) {
        throw handleError(err, "Exception for identifyPrincipal", {
            identifier: identifier,
        })
    }
}

/**
 * Searches for principals (users or organizations) by a given identifier.
 *
 * This function performs a fuzzy search for principals.
 *
 * @param fdm The FDM instance for database access.
 * @param identifier The identifier to search for (must be at least 2 characters long).
 * @returns A promise that resolves to an array of `Principal` objects.
 */
export async function lookupPrincipal(
    fdm: FdmType,
    identifier: string,
): Promise<Principal[]> {
    try {
        return await fdm.transaction(async (tx: FdmType) => {
            // Lookup if identifier is 1 or more characters
            if (identifier.length <= 1) {
                return []
            }

            // Check if identifier is email of user
            const principals = await tx
                .select({ id: authNSchema.user.id })
                .from(authNSchema.user)
                .where(eq(authNSchema.user.email, identifier))
                .limit(1)

            if (principals.length === 0) {
                // Check if identifier is close to organization name or slug
                const principalOrganizations = await tx
                    .select({ id: authNSchema.organization.id })
                    .from(authNSchema.organization)
                    .where(
                        or(
                            ilike(
                                authNSchema.organization.name,
                                `%${identifier}%`,
                            ),
                            ilike(
                                authNSchema.organization.slug,
                                `%${identifier}%`,
                            ),
                        ),
                    )
                    .limit(5)

                principals.push(...principalOrganizations)

                // Check if identifier is close to name of user
                const principalUsers = await tx
                    .select({ id: authNSchema.user.id })
                    .from(authNSchema.user)
                    .where(
                        or(
                            ilike(authNSchema.user.username, `%${identifier}%`),
                            ilike(
                                authNSchema.user.firstname,
                                `%${identifier}%`,
                            ),
                            ilike(authNSchema.user.surname, `%${identifier}%`),
                            ilike(authNSchema.user.name, `%${identifier}%`),
                        ),
                    )
                    .limit(5)
                principals.push(...principalUsers)
            }

            // Collect details of principals
            if (principals.length > 0) {
                const principalsDetails = await Promise.all(
                    principals.map(async (principal) => {
                        const details = await getPrincipal(tx, principal.id)
                        return details
                    }),
                )
                return principalsDetails.filter(Boolean)
            }

            return []
        })
    } catch (err) {
        throw handleError(err, "Exception for LookupPrincipal", {
            identifier: identifier,
        })
    }
}
